<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="310.96"
   height="367.914"
   id="svg3131"
   version="1.1"
   inkscape:version="0.48.3.1 r9886"
   sodipodi:docname="penguin-flat.svg">
  <metadata
     id="metadata3237">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <sodipodi:namedview
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1"
     objecttolerance="10"
     gridtolerance="10"
     guidetolerance="10"
     inkscape:pageopacity="0"
     inkscape:pageshadow="2"
     inkscape:window-width="1366"
     inkscape:window-height="718"
     id="namedview3235"
     showgrid="false"
     inkscape:zoom="0.5"
     inkscape:cx="123.65959"
     inkscape:cy="197.09734"
     inkscape:window-x="0"
     inkscape:window-y="0"
     inkscape:window-maximized="1"
     inkscape:current-layer="svg3131"
     showguides="true"
     inkscape:guide-bbox="true"
     showborder="false"
     inkscape:showpageshadow="false" />
  <defs
     id="defs3133">
    <marker
       id="ArrowEnd"
       viewBox="0 0 10 10"
       refX="0"
       refY="5"
       markerUnits="strokeWidth"
       markerWidth="4"
       markerHeight="3"
       orient="auto">
      <path
         d="M 0 0 L 10 5 L 0 10 z"
         id="path3136" />
    </marker>
    <marker
       id="ArrowStart"
       viewBox="0 0 10 10"
       refX="10"
       refY="5"
       markerUnits="strokeWidth"
       markerWidth="4"
       markerHeight="3"
       orient="auto">
      <path
         d="M 10 0 L 0 5 L 10 10 z"
         id="path3139" />
    </marker>
  </defs>
  <g
     id="g3141" />
  <path
     sodipodi:nodetypes="ccccccccccc"
     inkscape:connector-curvature="0"
     id="path3145"
     d="m 482.32933,382.11689 c 38.22888,145.31973 -38.77791,169.64772 -77.18691,223.61772 -38.436,54.18 -33.672,102.96 -104.7,83.982 -95.03904,-21.33129 -210.36675,-18.10962 -266.403,7.107 -45.333,20.505 -197.5299,-248.679 -209.8236,-298.782 -15.75024,-89.82102 42.39698,-196.85982 91.3017,-271.56 43.1163,-64.911 48.480459,-73.25517 68.3499,-167.616 -13.5819,-186.7392 -5.395509,-257.08324 76.497,-305.1642 77.916,-34.40008 170.86806,-24.6563 222.357,35.622 61.55388,81.00796 51.58521,151.92239 45.10524,268.45686 -12.51288,100.90245 122.64609,253.36458 154.50267,424.33662 z"
     style="fill:none;stroke:none;stroke-opacity:1" />
  <flowRoot
     xml:space="preserve"
     style="font-size:8px;font-style:normal;font-weight:500;line-height:100%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:TlwgTypewriter;-inkscape-font-specification:TlwgTypewriter Medium;font-stretch:normal;font-variant:normal;text-anchor:middle;text-align:center;writing-mode:lr;stroke-opacity:1"
     id="flowRoot3806"><flowRegion
       id="flowRegion3808"><use
         x="0"
         y="0"
         xlink:href="#path3145"
         id="use3810" /></flowRegion><flowPara
       id="flowPara3814"> #include &lt;linux/pid_namespace.h&gt; #include &lt;linux/clocksource.h&gt; #include &lt;linux/serial_core.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/spinlock.h&gt; #include &lt;linux/console.h&gt; #include &lt;linux/threads.h&gt; #include &lt;linux/uaccess.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/ptrace.h&gt; #include &lt;linux/string.h&gt; #include &lt;linux/delay.h&gt; #include &lt;linux/sched.h&gt; #include &lt;linux/sysrq.h&gt; #include &lt;linux/reboot.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/kgdb.h&gt; #include &lt;linux/kdb.h&gt; #include &lt;linux/pid.h&gt; #include &lt;linux/smp.h&gt; #include &lt;linux/mm.h&gt; #include &lt;linux/rcupdate.h&gt; #include &lt;asm/cacheflush.h&gt; #include &lt;asm/byteorder.h&gt; #include &lt;linux/atomic.h&gt; #include &quot;debug_core.h&quot;static int kgdb_break_asap; struct debuggerinfo_struct kgdb_info[NR_CPUS]; int kgdb_connected; EXPORT_SYMBOL_GPL (kgdb_connected); int kgdb_io_module_registered; static int exception_level; struct kgdb_io *dbg_io_ops; static DEFINE_SPINLOCK (kgdb_registration_lock); static int kgdbreboot; static int kgdb_con_registered; static int kgdb_use_con; bool dbg_is_early = true; int dbg_switch_cpu; int dbg_kdb_mode = 1; static int __init opt_kgdb_con (char *str){ kgdb_use_con = 1;  return 0; }early_param (&quot;kgdbcon&quot;, opt_kgdb_con); module_param (kgdb_use_con, int, 0644); module_param (kgdbreboot, int, 0644); static struct kgdb_bkpt kgdb_break[KGDB_MAX_BREAKPOINTS] = { [0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }}; atomic_t kgdb_active = ATOMIC_INIT (-1); EXPORT_SYMBOL_GPL (kgdb_active); static DEFINE_RAW_SPINLOCK (dbg_master_lock); static DEFINE_RAW_SPINLOCK (dbg_slave_lock); static atomic_t masters_in_kgdb; static atomic_t slaves_in_kgdb; static atomic_t kgdb_break_tasklet_var; atomic_t kgdb_setting_breakpoint; struct task_struct *kgdb_usethread; struct task_struct *kgdb_contthread; int kgdb_single_step; static pid_t kgdb_sstep_pid; atomic_t kgdb_cpu_doing_single_step = ATOMIC_INIT (-1); static int kgdb_do_roundup = 1; static int __init opt_nokgdbroundup (char *str){ kgdb_do_roundup = 0;  return 0; }early_param (&quot;nokgdbroundup&quot;, opt_nokgdbroundup); int __weak kgdb_arch_set_breakpoint (struct kgdb_bkpt *bpt){ int err;  err = probe_kernel_read (bpt-&gt;saved_instr,  (char *)bpt-&gt;bpt_addr, BREAK_INSTR_SIZE);  if  (err) return err;  err = probe_kernel_write ( (char *)bpt-&gt;bpt_addr, arch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);  return err; }int __weak kgdb_arch_remove_breakpoint (struct kgdb_bkpt *bpt){ return probe_kernel_write ( (char *)bpt-&gt;bpt_addr,  (char *)bpt-&gt;saved_instr, BREAK_INSTR_SIZE); }int __weak kgdb_validate_break_address (unsigned long addr){ struct kgdb_bkpt tmp;  int err;  tmp.bpt_addr = addr;  err = kgdb_arch_set_breakpoint (&amp;tmp);  if  (err) return err;  err = kgdb_arch_remove_breakpoint (&amp;tmp);  if  (err) printk (KERN_ERR &quot;KGDB: Critical breakpoint error, kernel &quot; &quot;memory destroyed at: %lx&quot;, addr);  return err; }unsigned long __weak kgdb_arch_pc (int exception, struct pt_regs *regs){ return instruction_pointer (regs); }int __weak kgdb_arch_init (void){ return 0; }int __weak kgdb_skipexception (int exception, struct pt_regs *regs){ return 0; }static void kgdb_flush_swbreak_addr (unsigned long addr){ if  (!CACHE_FLUSH_IS_SAFE) return;  if  (current-&gt;mm &amp;&amp; current-&gt;mm-&gt;mmap_cache) { flush_cache_range (current-&gt;mm-&gt;mmap_cache, addr, addr BREAK_INSTR_SIZE);  } flush_icache_range (addr, addr BREAK_INSTR_SIZE); }int dbg_activate_sw_breakpoints (void){ int error;  int ret = 0;  int i;  for  (i = 0;  i &lt; KGDB_MAX_BREAKPOINTS;  i++) { if  (kgdb_break[i].state != BP_SET) continue;  error = kgdb_arch_set_breakpoint (&amp;kgdb_break[i]);  if  (error) { ret = error;  printk (KERN_INFO &quot;KGDB: BP install failed: %lx&quot;, kgdb_break[i].bpt_addr);  continue;  } kgdb_flush_swbreak_addr (kgdb_break[i].bpt_addr);  kgdb_break[i].state = BP_ACTIVE;  } return ret; }int dbg_set_sw_break (unsigned long addr){ int err = kgdb_validate_break_address (addr);  int breakno = -1;  int i;  if  (err) return err;  for  (i = 0;  i &lt; KGDB_MAX_BREAKPOINTS;  i++) { if  ( (kgdb_break[i].state == BP_SET) &amp;&amp;  (kgdb_break[i].bpt_addr == addr)) return -EEXIST;  } for  (i = 0;  i &lt; KGDB_MAX_BREAKPOINTS;  i++) { if  (kgdb_break[i].state == BP_REMOVED &amp;&amp; kgdb_break[i].bpt_addr == addr) { breakno = i;  break;  } } if  (breakno == -1) { for  (i = 0;  i &lt; KGDB_MAX_BREAKPOINTS;  i++) { if  (kgdb_break[i].state == BP_UNDEFINED) { breakno = i;  break;  } } } if  (breakno == -1) return -E2BIG;  kgdb_break[breakno].state = BP_SET;  kgdb_break[breakno].type = BP_BREAKPOINT;  kgdb_break[breakno].bpt_addr = addr;  return 0; }int dbg_deactivate_sw_breakpoints (void){ int error;  int ret = 0;  int i;  for  (i = 0;  i &lt; KGDB_MAX_BREAKPOINTS;  i++) { if  (kgdb_break[i].state != BP_ACTIVE) continue;  error = kgdb_arch_remove_breakpoint (&amp;kgdb_break[i]);  if  (error) { printk (KERN_INFO &quot;KGDB: BP remove failed: %lx\n&quot;, kgdb_break[i].bpt_addr);  ret = error;  } kgdb_flush_swbreak_addr (kgdb_break[i].bpt_addr);  kgdb_break[i].state = BP_SET;  } return ret; }int dbg_remove_sw_break (unsigned long addr){ int i;  for  (i = 0;  i &lt; KGDB_MAX_BREAKPOINTS;  i++) { if  ( (kgdb_break[i].state == BP_SET) &amp;&amp;  (kgdb_break[i].bpt_addr == addr)) { kgdb_break[i].state = BP_REMOVED;  return 0;  } } return -ENOENT; }int kgdb_isremovedbreak (unsigned long addr){ int i;  for  (i = 0;  i &lt; KGDB_MAX_BREAKPOINTS;  i++) { if  ( (kgdb_break[i].state == BP_REMOVED) &amp;&amp;  (kgdb_break[i].bpt_addr == addr)) return 1;  } return 0; }int dbg_remove_all_break (void){ int error;  int i;  for  (i = 0;  i &lt; KGDB_MAX_BREAKPOINTS;  i++) { if  (kgdb_break[i].state != BP_ACTIVE) goto setundefined;  error = kgdb_arch_remove_breakpoint (&amp;kgdb_break[i]);  if  (error) printk (KERN_ERR &quot;KGDB: breakpoint remove failed: %lx\n&quot;, kgdb_break[i].bpt_addr); setundefined: kgdb_break[i].state = BP_UNDEFINED;  } if  (arch_kgdb_ops.remove_all_hw_break) arch_kgdb_ops.remove_all_hw_break ();  return 0; }static int kgdb_io_ready (int print_wait){ if  (!dbg_io_ops) return 0;  if  (kgdb_connected) return 1;  if  (atomic_read (&amp;kgdb_setting_breakpoint)) return 1;  if  (print_wait) { #ifdef CONFIG_KGDB_KDB if  (!dbg_kdb_mode) printk (KERN_CRIT &quot;KGDB: waiting... or $3 #33 for KDB\n&quot;);  #else printk (KERN_CRIT &quot;KGDB: Waiting for remote debugger\n&quot;);  #endif } return 1; }static int kgdb_reenter_check (struct kgdb_state *ks){ unsigned long addr;  if  (atomic_read (&amp;kgdb_active) != raw_smp_processor_id ()) return 0;  exception_level++;  addr = kgdb_arch_pc (ks-&gt;ex_vector, ks-&gt;linux_regs);  dbg_deactivate_sw_breakpoints ();  if  (dbg_remove_sw_break (addr) == 0) { exception_level = 0;  kgdb_skipexception (ks-&gt;ex_vector, ks-&gt;linux_regs);  dbg_activate_sw_breakpoints ();  printk (KERN_CRIT &quot;KGDB: re-enter error: breakpoint removed %lx\n&quot;, addr);  WARN_ON_ONCE (1);  return 1;  } dbg_remove_all_break ();  kgdb_skipexception (ks-&gt;ex_vector, ks-&gt;linux_regs);  if  (exception_level &gt; 1) { dump_stack ();  panic (&quot;Recursive entry to debugger&quot;);  } printk (KERN_CRIT &quot;KGDB: re-enter exception: ALL breakpoints killed\n&quot;);  #ifdef CONFIG_KGDB_KDB return 0;  #endif dump_stack ();  panic (&quot;Recursive entry to debugger&quot;);  return 1; }static void dbg_touch_watchdogs (void){ touch_softlockup_watchdog_sync ();  clocksource_touch_watchdog ();  rcu_cpu_stall_reset (); }static int kgdb_cpu_enter (struct kgdb_state *ks, struct pt_regs *regs, int exception_state){ unsigned long flags;  int sstep_tries = 100;  int error;  int cpu;  int trace_on = 0;  int online_cpus = num_online_cpus ();  kgdb_info[ks-&gt;cpu].enter_kgdb++;  kgdb_info[ks-&gt;cpu].exception_state |= exception_state;  if  (exception_state == DCPU_WANT_MASTER) atomic_inc (&amp;masters_in_kgdb);  else atomic_inc (&amp;slaves_in_kgdb);  if  (arch_kgdb_ops.disable_hw_break) arch_kgdb_ops.disable_hw_break (regs); acquirelock: local_irq_save (flags);  cpu = ks-&gt;cpu;  kgdb_info[cpu].debuggerinfo = regs;  kgdb_info[cpu].task = current;  kgdb_info[cpu].ret_state = 0;  kgdb_info[cpu].irq_depth = hardirq_count () &gt;&gt; HARDIRQ_SHIFT;  smp_mb ();  if  (exception_level == 1) { if  (raw_spin_trylock (&amp;dbg_master_lock)) atomic_xchg (&amp;kgdb_active, cpu);  goto cpu_master_loop;  } while  (1) {cpu_loop: if  (kgdb_info[cpu].exception_state &amp; DCPU_NEXT_MASTER) { kgdb_info[cpu].exception_state &amp;= ~DCPU_NEXT_MASTER;  goto cpu_master_loop;  } else if  (kgdb_info[cpu].exception_state &amp; DCPU_WANT_MASTER) { if  (raw_spin_trylock (&amp;dbg_master_lock)) { atomic_xchg (&amp;kgdb_active, cpu);  break;  } } else if  (kgdb_info[cpu].exception_state &amp; DCPU_IS_SLAVE) { if  (!raw_spin_is_locked (&amp;dbg_slave_lock)) goto return_normal;  } else {return_normal: if  (arch_kgdb_ops.correct_hw_break) arch_kgdb_ops.correct_hw_break ();  if  (trace_on) tracing_on ();  kgdb_info[cpu].exception_state &amp;= ~ (DCPU_WANT_MASTER | DCPU_IS_SLAVE);  kgdb_info[cpu].enter_kgdb--;  smp_mb__before_atomic_dec ();  atomic_dec (&amp;slaves_in_kgdb);  dbg_touch_watchdogs ();  local_irq_restore (flags);  return 0;  } cpu_relax ();  } if  (atomic_read (&amp;kgdb_cpu_doing_single_step) != -1 &amp;&amp;  (kgdb_info[cpu].task &amp;&amp; kgdb_info[cpu].task-&gt;pid != kgdb_sstep_pid) &amp;&amp; --sstep_tries) { atomic_set (&amp;kgdb_active, -1);  raw_spin_unlock (&amp;dbg_master_lock);  dbg_touch_watchdogs ();  local_irq_restore (flags);  goto acquirelock;  } if  (!kgdb_io_ready (1)) { kgdb_info[cpu].ret_state = 1;  goto kgdb_restore;  } if  (kgdb_skipexception (ks-&gt;ex_vector, ks-&gt;linux_regs)) goto kgdb_restore;  if  (dbg_io_ops-&gt;pre_exception) dbg_io_ops-&gt;pre_exception ();  if  (!kgdb_single_step) raw_spin_lock (&amp;dbg_slave_lock);  #ifdef CONFIG_SMP if  ( (!kgdb_single_step) &amp;&amp; kgdb_do_roundup) kgdb_roundup_cpus (flags);  #endif while  (kgdb_do_roundup &amp;&amp;  (atomic_read (&amp;masters_in_kgdb) atomic_read (&amp;slaves_in_kgdb)) != online_cpus) cpu_relax ();  dbg_deactivate_sw_breakpoints ();  kgdb_single_step = 0;  kgdb_contthread = current;  exception_level = 0;  trace_on = tracing_is_on ();  if  (trace_on) tracing_off ();  while  (1) {cpu_master_loop: if  (dbg_kdb_mode) { kgdb_connected = 1;  error = kdb_stub (ks);  if  (error == -1) continue;  kgdb_connected = 0;  } else { error = gdb_serial_stub (ks);  } if  (error == DBG_PASS_EVENT) { dbg_kdb_mode = !dbg_kdb_mode;  } else if  (error == DBG_SWITCH_CPU_EVENT) { kgdb_info[dbg_switch_cpu].exception_state |= DCPU_NEXT_MASTER;  goto cpu_loop;  } else { kgdb_info[cpu].ret_state = error;  break;  } } if  (dbg_io_ops-&gt;post_exception) dbg_io_ops-&gt;post_exception ();  if  (!kgdb_single_step) { raw_spin_unlock (&amp;dbg_slave_lock);  while  (kgdb_do_roundup &amp;&amp; atomic_read (&amp;slaves_in_kgdb)) cpu_relax ();  }kgdb_restore: if  (atomic_read (&amp;kgdb_cpu_doing_single_step) != -1) { int sstep_cpu = atomic_read (&amp;kgdb_cpu_doing_single_step);  if  (kgdb_info[sstep_cpu].task) kgdb_sstep_pid = kgdb_info[sstep_cpu].task-&gt;pid;  else kgdb_sstep_pid = 0;  } if  (arch_kgdb_ops.correct_hw_break) arch_kgdb_ops.correct_hw_break ();  if  (trace_on) tracing_on ();  kgdb_info[cpu].exception_state &amp;= ~ (DCPU_WANT_MASTER | DCPU_IS_SLAVE);  kgdb_info[cpu].enter_kgdb--;  smp_mb__before_atomic_dec ();  atomic_dec (&amp;masters_in_kgdb);  atomic_set (&amp;kgdb_active, -1);  raw_spin_unlock (&amp;dbg_master_lock);  dbg_touch_watchdogs ();  local_irq_restore (flags);  return kgdb_info[cpu].ret_state; }intkgdb_handle_exception (int evector, int signo, int ecode, struct pt_regs *regs){ struct kgdb_state kgdb_var;  struct kgdb_state *ks = &amp;kgdb_var;  int ret = 0;  if  (arch_kgdb_ops.enable_nmi) arch_kgdb_ops.enable_nmi (0);  ks-&gt;cpu = raw_smp_processor_id ();  ks-&gt;ex_vector = evector;  ks-&gt;signo = signo;  ks-&gt;err_code = ecode;  ks-&gt;kgdb_usethreadid = 0;  ks-&gt;linux_regs = regs;  if  (kgdb_reenter_check (ks)) goto out;  if  (kgdb_info[ks-&gt;cpu].enter_kgdb != 0) goto out;  ret = kgdb_cpu_enter (ks, regs, DCPU_WANT_MASTER); out: if  (arch_kgdb_ops.enable_nmi) arch_kgdb_ops.enable_nmi (1);  return ret; }static int module_event (struct notifier_block *self, unsigned long val, void *data){ return 0; }static struct notifier_block dbg_module_load_nb = { .notifier_call = module_event,}; int kgdb_nmicallback (int cpu, void *regs){ #ifdef CONFIG_SMP struct kgdb_state kgdb_var;  struct kgdb_state *ks = &amp;kgdb_var;  memset (ks, 0, sizeof (struct kgdb_state));  ks-&gt;cpu = cpu;  ks-&gt;linux_regs = regs;  if  (kgdb_info[ks-&gt;cpu].enter_kgdb == 0 &amp;&amp; raw_spin_is_locked (&amp;dbg_master_lock)) { kgdb_cpu_enter (ks, regs, DCPU_IS_SLAVE);  return 0;  } #endif return 1; }static void kgdb_console_write (struct console *co, const char *s, unsigned count){ unsigned long flags;  if  (!kgdb_connected || atomic_read (&amp;kgdb_active) != -1 || dbg_kdb_mode) return;  local_irq_save (flags);  gdbstub_msg_write (s, count);  local_irq_restore (flags); }static struct console kgdbcons = { .name = &quot;kgdb&quot;, .write = kgdb_console_write, .flags = CON_PRINTBUFFER | CON_ENABLED, .index = -1,};  #ifdef CONFIG_MAGIC_SYSRQstatic void sysrq_handle_dbg (int key){ if  (!dbg_io_ops) { printk (KERN_CRIT &quot;ERROR: No KGDB I/O module available\n&quot;);  return;  } if  (!kgdb_connected) { #ifdef CONFIG_KGDB_KDB if  (!dbg_kdb_mode) printk (KERN_CRIT &quot;KGDB or $3 #33 for KDB\n&quot;);  #else printk (KERN_CRIT &quot;Entering KGDB\n&quot;);  #endif } kgdb_breakpoint (); }static struct sysrq_key_op sysrq_dbg_op = { .handler = sysrq_handle_dbg, .help_msg = &quot;debug (g)&quot;, .action_msg = &quot;DEBUG&quot;,};  #endifstatic int kgdb_panic_event (struct notifier_block *self, unsigned long val, void *data){ if  (dbg_kdb_mode) kdb_printf (&quot;PANIC: %s\n&quot;,  (char *)data);  kgdb_breakpoint ();  return NOTIFY_DONE; }static struct notifier_block kgdb_panic_event_nb = { .notifier_call = kgdb_panic_event, .priority = INT_MAX,}; void __weak kgdb_arch_late (void){}void __init dbg_late_init (void){ dbg_is_early = false;  if  (kgdb_io_module_registered) kgdb_arch_late ();  kdb_init (KDB_INIT_FULL); }static intdbg_notify_reboot (struct notifier_block *this, unsigned long code, void *x){ switch  (kgdbreboot) { case 1: kgdb_breakpoint ();  case -1: goto done;  } if  (!dbg_kdb_mode) gdbstub_exit (code); done: return NOTIFY_DONE; }static struct notifier_block dbg_reboot_notifier = { .notifier_call = dbg_notify_reboot, .next = NULL, .priority = INT_MAX,}; static void kgdb_register_callbacks (void){ if  (!kgdb_io_module_registered) { kgdb_io_module_registered = 1;  kgdb_arch_init ();  if  (!dbg_is_early) kgdb_arch_late ();  register_module_notifier (&amp;dbg_module_load_nb);  register_reboot_notifier (&amp;dbg_reboot_notifier);  atomic_notifier_chain_register (&amp;panic_notifier_list, &amp;kgdb_panic_event_nb);  #ifdef CONFIG_MAGIC_SYSRQ register_sysrq_key ('g', &amp;sysrq_dbg_op);  #endif if  (kgdb_use_con &amp;&amp; !kgdb_con_registered) { register_console (&amp;kgdbcons);  kgdb_con_registered = 1;  } }}static void kgdb_unregister_callbacks (void){ if  (kgdb_io_module_registered) { kgdb_io_module_registered = 0;  unregister_reboot_notifier (&amp;dbg_reboot_notifier);  unregister_module_notifier (&amp;dbg_module_load_nb);  atomic_notifier_chain_unregister (&amp;panic_notifier_list, &amp;kgdb_panic_event_nb);  kgdb_arch_exit ();  #ifdef CONFIG_MAGIC_SYSRQ unregister_sysrq_key ('g', &amp;sysrq_dbg_op);  #endif if  (kgdb_con_registered) { unregister_console (&amp;kgdbcons);  kgdb_con_registered = 0;  } }}static void kgdb_tasklet_bpt (unsigned long ing){ kgdb_breakpoint ();  atomic_set (&amp;kgdb_break_tasklet_var, 0); }static DECLARE_TASKLET (kgdb_tasklet_breakpoint, kgdb_tasklet_bpt, 0); void kgdb_schedule_breakpoint (void){ if  (atomic_read (&amp;kgdb_break_tasklet_var) || atomic_read (&amp;kgdb_active) != -1 || atomic_read (&amp;kgdb_setting_breakpoint)) return;  atomic_inc (&amp;kgdb_break_tasklet_var);  tasklet_schedule (&amp;kgdb_tasklet_breakpoint); }EXPORT_SYMBOL_GPL (kgdb_schedule_breakpoint); static void kgdb_initial_breakpoint (void){ kgdb_break_asap = 0;  printk (KERN_CRIT &quot;kgdb: Waiting for connection from remote gdb...\n&quot;);  kgdb_breakpoint (); }int kgdb_register_io_module (struct kgdb_io *new_dbg_io_ops){ int err;  spin_lock (&amp;kgdb_registration_lock);  if  (dbg_io_ops) { spin_unlock (&amp;kgdb_registration_lock);  printk (KERN_ERR &quot;kgdb: Another I/O driver is already &quot; &quot;registered with KGDB.\n&quot;);  return -EBUSY;  } if  (new_dbg_io_ops-&gt;init) { err = new_dbg_io_ops-&gt;init ();  if  (err) { spin_unlock (&amp;kgdb_registration_lock);  return err;  } } dbg_io_ops = new_dbg_io_ops;  spin_unlock (&amp;kgdb_registration_lock);  printk (KERN_INFO &quot;kgdb: Registered I/O driver %s.\n&quot;, new_dbg_io_ops-&gt;name);  kgdb_register_callbacks ();  if  (kgdb_break_asap) kgdb_initial_breakpoint ();  return 0; }EXPORT_SYMBOL_GPL (kgdb_register_io_module); void kgdb_unregister_io_module (struct kgdb_io *old_dbg_io_ops){ BUG_ON (kgdb_connected);  kgdb_unregister_callbacks ();  spin_lock (&amp;kgdb_registration_lock);  WARN_ON_ONCE (dbg_io_ops != old_dbg_io_ops);  dbg_io_ops = NULL;  spin_unlock (&amp;kgdb_registration_lock);  printk (KERN_INFO &quot;kgdb: Unregistered I/O driver %s, debugger disabled.\n&quot;, old_dbg_io_ops-&gt;name); }EXPORT_SYMBOL_GPL (kgdb_unregister_io_module); int dbg_io_get_char (void){ int ret = dbg_io_ops-&gt;read_char ();  if  (ret == NO_POLL_CHAR) return -1;  if  (!dbg_kdb_mode) return ret;  if  (ret == 127) return 8;  return ret; }void kgdb_breakpoint (void){ atomic_inc (&amp;kgdb_setting_breakpoint);  wmb ();  arch_kgdb_breakpoint ();  wmb ();  atomic_dec (&amp;kgdb_setting_breakpoint); }EXPORT_SYMBOL_GPL (kgdb_breakpoint); static int __init opt_kgdb_wait (char *str){ kgdb_break_asap = 1;  kdb_init (KDB_INIT_EARLY);  if  (kgdb_io_module_registered) kgdb_initial_breakpoint ();  return 0; }early_param (&quot;kgdbwait&quot;, opt_kgdb_wait); </flowPara></flowRoot>  <g
     id="g3177"
     transform="matrix(3,0,0,3,-311.64158,-368.98939)"
     style="fill:#ffffff;stroke:none;stroke-opacity:1;fill-opacity:1">
    <path
       style="fill:#ffffff;stroke:none;stroke-opacity:1;fill-opacity:1"
       d="m 137.175,129.177 c -9.354,0.36 -17.69889,-20.59089 -18.88189,-10.96189 -1.6947,42.77432 -32.319968,56.15179 -41.70441,93.85589 -2.899617,14.95851 -10.184369,37.83466 -0.08,46.054 10.041284,11.96678 50.07425,26.43808 40.5873,47.353 -3.251,4.815 -16.151,4.253 -16.081,4.253 -0.07,0 11.199,13.376 13.138,15.326 1.869,1.868 12.158,10.715 44.97,4.598 18.489,-3.458 32.812,-13.812 43.175,-23.816 14.50173,-13.08201 18.32512,-26.89916 22.435,-44.994 -1.74404,-62.91175 -48.84351,-111.23238 -40.64154,-158.1491 -14.532,0.791 -33.17446,25.9011 -46.91646,26.4811 z"
       id="path3179"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cccccccccccc" />
  </g>
  <path
     sodipodi:nodetypes="cccccccccccc"
     inkscape:connector-curvature="0"
     id="path3191-2"
     d="m 548.56342,433.15961 c 23.60139,44.90103 -12.72879,53.48277 51.741,94.524 24.71292,17.38683 30.24717,42.63057 6.477,65.967 -56.0307,37.23903 -116.80953,66.294 -163.23,112.47 -32.76177,28.94076 -97.02876,41.25366 -129.948,12.738 -38.88405,-51.85227 -8.92629,-125.64534 -3.657,-176.601 2.16,-21.795 1.917,-48.78 1.917,-72.738 2.47752,-41.48601 -7.73073,-67.5036 34.989,-67.581 13.824,0 20.061,0.87 24.618,5.394 5.48202,39.35016 10.4163,63.74286 47.046,67.134 51.45237,15.79251 58.66137,-51.73041 87.639,-59.997 2.16,0 31.48983,-2.77791 42.408,18.69 z"
     style="fill:#ffffff;stroke:none" />
  <path
     sodipodi:nodetypes="cccccccccc"
     inkscape:connector-curvature="0"
     id="path3193-8"
     d="m -222.43748,454.40861 c -19.428,14.034 -62.63088,12.714 -75.16485,29.142 -14.25481,21.30597 14.29014,70.54116 12.08935,87.13617 -6.13557,24.40884 -33.33076,56.38593 -22.19938,76.48383 11.037,18.348 28.72518,22.878 129.97788,44.049 54.18,11.211 105.333,40.353 139.6653,43.173 137.2509,-20.55723 66.87798,-128.00787 33.0396,-180.471 -29.5929,-46.863 -34.3326,-55.494 -53.9679,-86.559 -19.641,-30.675 -58.5,-86.352 -80.748,-87.015 -43.85122,3.51816 -55.10434,53.1753 -82.692,74.061 z"
     style="fill:#ffffff;stroke:none" />
  <path
     sodipodi:nodetypes="ccccc"
     inkscape:connector-curvature="0"
     id="path3197"
     d="m 65.34142,-84.00259 c 25.44414,-12.438609 32.24886,-43.94578 32.172,-67.371 -1.66824,-28.43768 -20.0049,-60.40408 -51.81,-55.26 -16.80447,8.6934 -23.42445,27.28987 -23.958,44.256 -2.18268,26.57773 12.05271,89.230617 43.596,78.375 z"
     style="fill:#ffffff;stroke:none" />
  <path
     sodipodi:nodetypes="cccccc"
     inkscape:connector-curvature="0"
     id="path3199"
     d="m 53.25742,-171.88159 c 17.51706,2.65238 25.51698,18.70555 25.698,33.459 0,13.824 -1.527,29.145 -9.717,33.909 -2.607,1.503 -8.214,2.79 -11.451,2.79 -14.05161,-3.62194 -24.07827,-23.86743 -24.411,-37.329 -0.47268,-15.13559 3.5409,-32.57133 19.881,-32.829 z"
     style="fill:#000000;stroke:none" />
  <path
     sodipodi:nodetypes="ccccc"
     inkscape:connector-curvature="0"
     id="path3201"
     d="m 199.18942,-81.21259 c 32.382,-3.447 43.833,-15.954 49.65,-37.779 7.11309,-42.17206 -9.14523,-92.39035 -50.073,-95.829 -47.48607,0.59494 -56.90823,44.28803 -56.367,68.424 1.85964,31.70121 20.4996,64.753551 56.79,65.184 z"
     style="fill:#ffffff;stroke:none" />
  <path
     sodipodi:nodetypes="ccccc"
     inkscape:connector-curvature="0"
     id="path3203"
     d="m 196.60942,-172.72159 c 16.191,0 25.665,14.451 28.902,33.012 2.20428,19.30335 -11.73186,36.96297 -30.432,37.359 -27.52023,0.10209 -27.50976,-11.92021 -27.615,-37.359 0.6027,-19.4749 10.22829,-32.89048 29.145,-33.012 z"
     style="fill:#000000;stroke:none" />
  <path
     sodipodi:nodetypes="ccccccccccc"
     inkscape:connector-curvature="0"
     id="path3215-3"
     d="m 114.78442,-129.54559 c 15.741,-1.95 37.329,1.917 47.283,9.264 9.264,6.927 15.741,10.584 24.168,13.401 28.275,9.266998 65.424,13.583998 63.684,39.070198 -1.95,30.435 -10.797,27.37932 -36.042,52.023003 -48.72636,29.79342 -56.577,41.436 -84.642,41.436 -42.80046,3.92472 -52.13925,-13.215 -79.425,-36.039 -15.981,-12.954 -30.882,-26.778003 -31.305,-44.919003 -0.657,-19.1892 11.877,-25.4562 29.568,-40.7742 9.294,-8.216998 26.115,-21.827998 37.779,-27.857998 10.794,-5.397 17.688,-4.314 28.932,-5.604 z"
     style="fill:#ffffff;stroke:none" />
  <g
     id="g3223"
     transform="matrix(3,0,0,3,-311.64158,-368.98939)">
    <path
       style="fill:#ffffff;stroke:none"
       d="m 269.516,256.913 c 0.199,2.551 -1.296,1.586 -2.782,-0.682 -13.1919,-11.5477 -22.49101,-6.19688 -34.977,-2.543 18.62907,-10.27583 25.48209,-6.29795 37.759,3.225 z"
       id="path3227"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cccc" />
  </g>
  <flowRoot
     xml:space="preserve"
     id="flowRoot3794"
     style="font-size:40px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"><flowRegion
       id="flowRegion3796"><rect
         id="rect3798"
         width="84.640938"
         height="71.685692"
         x="-215.92075"
         y="-25.061768" /></flowRegion><flowPara
       id="flowPara3800" /></flowRoot>  <path
     sodipodi:nodetypes="cccccccccc"
     inkscape:connector-curvature="0"
     id="path3193"
     d="m -222.43748,454.40861 c -19.428,14.034 -62.63088,12.714 -75.16485,29.142 -14.25481,21.30597 14.29014,70.54116 12.08935,87.13617 -6.13557,24.40884 -33.33076,56.38593 -22.19938,76.48383 11.037,18.348 28.72518,22.878 129.97788,44.049 54.18,11.211 105.333,40.353 139.6653,43.173 137.2509,-20.55723 66.87798,-128.00787 33.0396,-180.471 -29.5929,-46.863 -34.3326,-55.494 -53.9679,-86.559 -19.641,-30.675 -58.5,-86.352 -80.748,-87.015 -43.85122,3.51816 -55.10434,53.1753 -82.692,74.061 z"
     style="fill:none;stroke:#ffffff;stroke-opacity:1;stroke-width:6;stroke-miterlimit:4;stroke-dasharray:none" />
  <path
     sodipodi:nodetypes="cccccccccccc"
     inkscape:connector-curvature="0"
     id="path3191"
     d="m 548.56342,433.15961 c 23.60139,44.90103 -12.72879,53.48277 51.741,94.524 24.71292,17.38683 30.24717,42.63057 6.477,65.967 -56.0307,37.23903 -116.80953,66.294 -163.23,112.47 -32.76177,28.94076 -97.02876,41.25366 -129.948,12.738 -38.88405,-51.85227 -8.92629,-125.64534 -3.657,-176.601 2.16,-21.795 1.917,-48.78 1.917,-72.738 2.47752,-41.48601 -7.73073,-67.5036 34.989,-67.581 13.824,0 20.061,0.87 24.618,5.394 5.48202,39.35016 10.4163,63.74286 47.046,67.134 51.45237,15.79251 58.66137,-51.73041 87.639,-59.997 2.16,0 31.48983,-2.77791 42.408,18.69 z"
     style="fill:none;stroke:#ffffff;stroke-opacity:1;stroke-width:6;stroke-miterlimit:4;stroke-dasharray:none" />
  <path
     sodipodi:nodetypes="ccccccccccc"
     inkscape:connector-curvature="0"
     id="path3215"
     d="m 114.78442,-129.54559 c 15.741,-1.95 37.329,1.917 47.283,9.264 9.264,6.927 15.741,10.584 24.168,13.401 28.275,9.267 65.424,13.584 63.684,39.0702 -1.95,30.435 -10.797,27.37932 -36.042,52.023 -48.72636,29.79342 -56.577,41.436 -84.642,41.436 -42.80046,3.92472 -52.13925,-13.215 -79.425,-36.039 -15.981,-12.954 -30.882,-26.778 -31.305,-44.919 -0.657,-19.1892 11.877,-25.4562 29.568,-40.7742 9.294,-8.217 26.115,-21.828 37.779,-27.858 10.794,-5.397 17.688,-4.314 28.932,-5.604 z"
     style="fill:none;stroke:#ffffff;stroke-opacity:1;stroke-width:6;stroke-miterlimit:4;stroke-dasharray:none" />
  <flowRoot
     xml:space="preserve"
     style="font-size:4px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:center;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:middle;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans;-inkscape-font-specification:Sans"
     id="flowRoot3890"
     transform="translate(-4.3585205e-6,4.8205484e-6)"><flowRegion
       id="flowRegion3892"><use
         x="0"
         y="0"
         xlink:href="#path3215"
         id="use3894"
         width="1"
         height="1" /><use
         x="0"
         y="0"
         xlink:href="#path3193"
         id="use3896"
         width="1"
         height="1" /><use
         x="0"
         y="0"
         xlink:href="#path3191"
         id="use3898"
         width="1"
         height="1" /></flowRegion><flowPara
       id="flowPara3900"> #include &lt;linux/pid_namespace.h&gt; #include &lt;linux/clocksource.h&gt; #include &lt;linux/serial_core.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/spinlock.h&gt; #include &lt;linux/console.h&gt; #include &lt;linux/threads.h&gt; #include &lt;linux/uaccess.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/ptrace.h&gt; #include &lt;linux/string.h&gt; #include &lt;linux/delay.h&gt; #include &lt;linux/sched.h&gt; #include &lt;linux/sysrq.h&gt; #include &lt;linux/reboot.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/kgdb.h&gt; #include &lt;linux/kdb.h&gt; #include &lt;linux/pid.h&gt; #include &lt;linux/smp.h&gt; #include &lt;linux/mm.h&gt; #include &lt;linux/rcupdate.h&gt; #include &lt;asm/cacheflush.h&gt; #include &lt;asm/byteorder.h&gt; #include &lt;linux/atomic.h&gt; #include &quot;debug_core.h&quot;static int kgdb_break_asap; struct debuggerinfo_struct kgdb_info[NR_CPUS]; int kgdb_connected; EXPORT_SYMBOL_GPL (kgdb_connected); int kgdb_io_module_registered; static int exception_level; struct kgdb_io *dbg_io_ops; static DEFINE_SPINLOCK (kgdb_registration_lock); static int kgdbreboot; static int kgdb_con_registered; static int kgdb_use_con; bool dbg_is_early = true; int dbg_switch_cpu; int dbg_kdb_mode = 1; static int __init opt_kgdb_con (char *str){ kgdb_use_con = 1;  return 0; }early_param (&quot;kgdbcon&quot;, opt_kgdb_con); module_param (kgdb_use_con, int, 0644); module_param (kgdbreboot, int, 0644); static struct kgdb_bkpt kgdb_break[KGDB_MAX_BREAKPOINTS] = { [0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }}; atomic_t kgdb_active = ATOMIC_INIT (-1); EXPORT_SYMBOL_GPL (kgdb_active); static DEFINE_RAW_SPINLOCK (dbg_master_lock); static DEFINE_RAW_SPINLOCK (dbg_slave_lock); static atomic_t masters_in_kgdb; static atomic_t slaves_in_kgdb; static atomic_t kgdb_break_tasklet_var; atomic_t kgdb_setting_breakpoint; struct task_struct *kgdb_usethread; struct task_struct *kgdb_contthread; int kgdb_single_step; static pid_t kgdb_sstep_pid; atomic_t kgdb_cpu_doing_single_step = ATOMIC_INIT (-1); static int kgdb_do_roundup = 1; static int __init opt_nokgdbroundup (char *str){ kgdb_do_roundup = 0;  return 0; }early_param (&quot;nokgdbroundup&quot;, opt_nokgdbroundup); int __weak kgdb_arch_set_breakpoint (struct kgdb_bkpt *bpt){ int err;  err = probe_kernel_read (bpt-&gt;saved_instr,  (char *)bpt-&gt;bpt_addr, BREAK_INSTR_SIZE);  if  (err) return err;  err = probe_kernel_write ( (char *)bpt-&gt;bpt_addr, arch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);  return err; }int __weak kgdb_arch_remove_breakpoint (struct kgdb_bkpt *bpt){ return probe_kernel_write ( (char *)bpt-&gt;bpt_addr,  (char *)bpt-&gt;saved_instr, BREAK_INSTR_SIZE); }int __weak kgdb_validate_break_address (unsigned long addr){ struct kgdb_bkpt tmp;  int err;  tmp.bpt_addr = addr;  err = kgdb_arch_set_breakpoint (&amp;tmp);  if  (err) return err;  err = kgdb_arch_remove_breakpoint (&amp;tmp);  if  (err) printk (KERN_ERR &quot;KGDB: Critical breakpoint error, kernel &quot; &quot;memory destroyed at: %lx&quot;, addr);  return err; }unsigned long __weak kgdb_arch_pc (int exception, struct pt_regs *regs){ return instruction_pointer (regs); }int __weak kgdb_arch_init (void){ return 0; }int __weak kgdb_skipexception (int exception, struct pt_regs *regs){ return 0; }static void kgdb_flush_swbreak_addr (unsigned long addr){ if  (!CACHE_FLUSH_IS_SAFE) return;  if  (current-&gt;mm &amp;&amp; current-&gt;mm-&gt;mmap_cache) { flush_cache_range (current-&gt;mm-&gt;mmap_cache, addr, addr BREAK_INSTR_SIZE);  } flush_icache_range (addr, addr BREAK_INSTR_SIZE); }int dbg_activate_sw_breakpoints (void){ int error;  int ret = 0;  int i;  for  (i = 0;  i &lt; KGDB_MAX_BREAKPOINTS;  i++) { if  (kgdb_break[i].state != BP_SET) continue;  error = kgdb_arch_set_breakpoint (&amp;kgdb_break[i]);  if  (error) { ret = error;  printk (KERN_INFO &quot;KGDB: BP install failed: %lx&quot;, kgdb_break[i].bpt_addr);  continue;  } kgdb_flush_swbreak_addr (kgdb_break[i].bpt_addr);  kgdb_break[i].state = BP_ACTIVE;  } return ret; }int dbg_set_sw_break (unsigned long addr){ int err = kgdb_validate_break_address (addr);  int breakno = -1;  int i;  if  (err) return err;  for  (i = 0;  i &lt; KGDB_MAX_BREAKPOINTS;  i++) { if  ( (kgdb_break[i].state == BP_SET) &amp;&amp;  (kgdb_break[i].bpt_addr == addr)) return -EEXIST;  } for  (i = 0;  i &lt; KGDB_MAX_BREAKPOINTS;  i++) { if  (kgdb_break[i].state == BP_REMOVED &amp;&amp; kgdb_break[i].bpt_addr == addr) { breakno = i;  break;  } } if  (breakno == -1) { for  (i = 0;  i &lt; KGDB_MAX_BREAKPOINTS;  i++) { if  (kgdb_break[i].state == BP_UNDEFINED) { breakno = i;  break;  } } } if  (breakno == -1) return -E2BIG;  kgdb_break[breakno].state = BP_SET;  kgdb_break[breakno].type = BP_BREAKPOINT;  kgdb_break[breakno].bpt_addr = addr;  return 0; }int dbg_deactivate_sw_breakpoints (void){ int error;  int ret = 0;  int i;  for  (i = 0;  i &lt; KGDB_MAX_BREAKPOINTS;  i++) { if  (kgdb_break[i].state != BP_ACTIVE) continue;  error = kgdb_arch_remove_breakpoint (&amp;kgdb_break[i]);  if  (error) { printk (KERN_INFO &quot;KGDB: BP remove failed: %lx\n&quot;, kgdb_break[i].bpt_addr);  ret = error;  } kgdb_flush_swbreak_addr (kgdb_break[i].bpt_addr);  kgdb_break[i].state = BP_SET;  } return ret; }int dbg_remove_sw_break (unsigned long addr){ int i;  for  (i = 0;  i &lt; KGDB_MAX_BREAKPOINTS;  i++) { if  ( (kgdb_break[i].state == BP_SET) &amp;&amp;  (kgdb_break[i].bpt_addr == addr)) { kgdb_break[i].state = BP_REMOVED;  return 0;  } } return -ENOENT; }int kgdb_isremovedbreak (unsigned long addr){ int i;  for  (i = 0;  i &lt; KGDB_MAX_BREAKPOINTS;  i++) { if  ( (kgdb_break[i].state == BP_REMOVED) &amp;&amp;  (kgdb_break[i].bpt_addr == addr)) return 1;  } return 0; }int dbg_remove_all_break (void){ int error;  int i;  for  (i = 0;  i &lt; KGDB_MAX_BREAKPOINTS;  i++) { if  (kgdb_break[i].state != BP_ACTIVE) goto setundefined;  error = kgdb_arch_remove_breakpoint (&amp;kgdb_break[i]);  if  (error) printk (KERN_ERR &quot;KGDB: breakpoint remove failed: %lx\n&quot;, kgdb_break[i].bpt_addr); setundefined: kgdb_break[i].state = BP_UNDEFINED;  } if  (arch_kgdb_ops.remove_all_hw_break) arch_kgdb_ops.remove_all_hw_break ();  return 0; }static int kgdb_io_ready (int print_wait){ if  (!dbg_io_ops) return 0;  if  (kgdb_connected) return 1;  if  (atomic_read (&amp;kgdb_setting_breakpoint)) return 1;  if  (print_wait) { #ifdef CONFIG_KGDB_KDB if  (!dbg_kdb_mode) printk (KERN_CRIT &quot;KGDB: waiting... or $3 #33 for KDB\n&quot;);  #else printk (KERN_CRIT &quot;KGDB: Waiting for remote debugger\n&quot;);  #endif } return 1; }static int kgdb_reenter_check (struct kgdb_state *ks){ unsigned long addr;  if  (atomic_read (&amp;kgdb_active) != raw_smp_processor_id ()) return 0;  exception_level++;  addr = kgdb_arch_pc (ks-&gt;ex_vector, ks-&gt;linux_regs);  dbg_deactivate_sw_breakpoints ();  if  (dbg_remove_sw_break (addr) == 0) { exception_level = 0;  kgdb_skipexception (ks-&gt;ex_vector, ks-&gt;linux_regs);  dbg_activate_sw_breakpoints ();  printk (KERN_CRIT &quot;KGDB: re-enter error: breakpoint removed %lx\n&quot;, addr);  WARN_ON_ONCE (1);  return 1;  } dbg_remove_all_break ();  kgdb_skipexception (ks-&gt;ex_vector, ks-&gt;linux_regs);  if  (exception_level &gt; 1) { dump_stack ();  panic (&quot;Recursive entry to debugger&quot;);  } printk (KERN_CRIT &quot;KGDB: re-enter exception: ALL breakpoints killed\n&quot;);  #ifdef CONFIG_KGDB_KDB return 0;  #endif dump_stack ();  panic (&quot;Recursive entry to debugger&quot;);  return 1; }static void dbg_touch_watchdogs (void){ touch_softlockup_watchdog_sync ();  clocksource_touch_watchdog ();  rcu_cpu_stall_reset (); }static int kgdb_cpu_enter (struct kgdb_state *ks, struct pt_regs *regs, int exception_state){ unsigned long flags;  int sstep_tries = 100;  int error;  int cpu;  int trace_on = 0;  int online_cpus = num_online_cpus ();  kgdb_info[ks-&gt;cpu].enter_kgdb++;  kgdb_info[ks-&gt;cpu].exception_state |= exception_state;  if  (exception_state == DCPU_WANT_MASTER) atomic_inc (&amp;masters_in_kgdb);  else atomic_inc (&amp;slaves_in_kgdb);  if  (arch_kgdb_ops.disable_hw_break) arch_kgdb_ops.disable_hw_break (regs); acquirelock: local_irq_save (flags);  cpu = ks-&gt;cpu;  kgdb_info[cpu].debuggerinfo = regs;  kgdb_info[cpu].task = current;  kgdb_info[cpu].ret_state = 0;  kgdb_info[cpu].irq_depth = hardirq_count () &gt;&gt; HARDIRQ_SHIFT;  smp_mb ();  if  (exception_level == 1) { if  (raw_spin_trylock (&amp;dbg_master_lock)) atomic_xchg (&amp;kgdb_active, cpu);  goto cpu_master_loop;  } while  (1) {cpu_loop: if  (kgdb_info[cpu].exception_state &amp; DCPU_NEXT_MASTER) { kgdb_info[cpu].exception_state &amp;= ~DCPU_NEXT_MASTER;  goto cpu_master_loop;  } else if  (kgdb_info[cpu].exception_state &amp; DCPU_WANT_MASTER) { if  (raw_spin_trylock (&amp;dbg_master_lock)) { atomic_xchg (&amp;kgdb_active, cpu);  break;  } } else if  (kgdb_info[cpu].exception_state &amp; DCPU_IS_SLAVE) { if  (!raw_spin_is_locked (&amp;dbg_slave_lock)) goto return_normal;  } else {return_normal: if  (arch_kgdb_ops.correct_hw_break) arch_kgdb_ops.correct_hw_break ();  if  (trace_on) tracing_on ();  kgdb_info[cpu].exception_state &amp;= ~ (DCPU_WANT_MASTER | DCPU_IS_SLAVE);  kgdb_info[cpu].enter_kgdb--;  smp_mb__before_atomic_dec ();  atomic_dec (&amp;slaves_in_kgdb);  dbg_touch_watchdogs ();  local_irq_restore (flags);  return 0;  } cpu_relax ();  } if  (atomic_read (&amp;kgdb_cpu_doing_single_step) != -1 &amp;&amp;  (kgdb_info[cpu].task &amp;&amp; kgdb_info[cpu].task-&gt;pid != kgdb_sstep_pid) &amp;&amp; --sstep_tries) { atomic_set (&amp;kgdb_active, -1);  raw_spin_unlock (&amp;dbg_master_lock);  dbg_touch_watchdogs ();  local_irq_restore (flags);  goto acquirelock;  } if  (!kgdb_io_ready (1)) { kgdb_info[cpu].ret_state = 1;  goto kgdb_restore;  } if  (kgdb_skipexception (ks-&gt;ex_vector, ks-&gt;linux_regs)) goto kgdb_restore;  if  (dbg_io_ops-&gt;pre_exception) dbg_io_ops-&gt;pre_exception ();  if  (!kgdb_single_step) raw_spin_lock (&amp;dbg_slave_lock);  #ifdef CONFIG_SMP if  ( (!kgdb_single_step) &amp;&amp; kgdb_do_roundup) kgdb_roundup_cpus (flags);  #endif while  (kgdb_do_roundup &amp;&amp;  (atomic_read (&amp;masters_in_kgdb) atomic_read (&amp;slaves_in_kgdb)) != online_cpus) cpu_relax ();  dbg_deactivate_sw_breakpoints ();  kgdb_single_step = 0;  kgdb_contthread = current;  exception_level = 0;  trace_on = tracing_is_on ();  if  (trace_on) tracing_off ();  while  (1) {cpu_master_loop: if  (dbg_kdb_mode) { kgdb_connected = 1;  error = kdb_stub (ks);  if  (error == -1) continue;  kgdb_connected = 0;  } else { error = gdb_serial_stub (ks);  } if  (error == DBG_PASS_EVENT) { dbg_kdb_mode = !dbg_kdb_mode;  } else if  (error == DBG_SWITCH_CPU_EVENT) { kgdb_info[dbg_switch_cpu].exception_state |= DCPU_NEXT_MASTER;  goto cpu_loop;  } else { kgdb_info[cpu].ret_state = error;  break;  } } if  (dbg_io_ops-&gt;post_exception) dbg_io_ops-&gt;post_exception ();  if  (!kgdb_single_step) { raw_spin_unlock (&amp;dbg_slave_lock);  while  (kgdb_do_roundup &amp;&amp; atomic_read (&amp;slaves_in_kgdb)) cpu_relax ();  }kgdb_restore: if  (atomic_read (&amp;kgdb_cpu_doing_single_step) != -1) { int sstep_cpu = atomic_read (&amp;kgdb_cpu_doing_single_step);  if  (kgdb_info[sstep_cpu].task) kgdb_sstep_pid = kgdb_info[sstep_cpu].task-&gt;pid;  else kgdb_sstep_pid = 0;  } if  (arch_kgdb_ops.correct_hw_break) arch_kgdb_ops.correct_hw_break ();  if  (trace_on) tracing_on ();  kgdb_info[cpu].exception_state &amp;= ~ (DCPU_WANT_MASTER | DCPU_IS_SLAVE);  kgdb_info[cpu].enter_kgdb--;  smp_mb__before_atomic_dec ();  atomic_dec (&amp;masters_in_kgdb);  atomic_set (&amp;kgdb_active, -1);  raw_spin_unlock (&amp;dbg_master_lock);  dbg_touch_watchdogs ();  local_irq_restore (flags);  return kgdb_info[cpu].ret_state; }intkgdb_handle_exception (int evector, int signo, int ecode, struct pt_regs *regs){ struct kgdb_state kgdb_var;  struct kgdb_state *ks = &amp;kgdb_var;  int ret = 0;  if  (arch_kgdb_ops.enable_nmi) arch_kgdb_ops.enable_nmi (0);  ks-&gt;cpu = raw_smp_processor_id ();  ks-&gt;ex_vector = evector;  ks-&gt;signo = signo;  ks-&gt;err_code = ecode;  ks-&gt;kgdb_usethreadid = 0;  ks-&gt;linux_regs = regs;  if  (kgdb_reenter_check (ks)) goto out;  if  (kgdb_info[ks-&gt;cpu].enter_kgdb != 0) goto out;  ret = kgdb_cpu_enter (ks, regs, DCPU_WANT_MASTER); out: if  (arch_kgdb_ops.enable_nmi) arch_kgdb_ops.enable_nmi (1);  return ret; }static int module_event (struct notifier_block *self, unsigned long val, void *data){ return 0; }static struct notifier_block dbg_module_load_nb = { .notifier_call = module_event,}; int kgdb_nmicallback (int cpu, void *regs){ #ifdef CONFIG_SMP struct kgdb_state kgdb_var;  struct kgdb_state *ks = &amp;kgdb_var;  memset (ks, 0, sizeof (struct kgdb_state));  ks-&gt;cpu = cpu;  ks-&gt;linux_regs = regs;  if  (kgdb_info[ks-&gt;cpu].enter_kgdb == 0 &amp;&amp; raw_spin_is_locked (&amp;dbg_master_lock)) { kgdb_cpu_enter (ks, regs, DCPU_IS_SLAVE);  return 0;  } #endif return 1; }static void kgdb_console_write (struct console *co, const char *s, unsigned count){ unsigned long flags;  if  (!kgdb_connected || atomic_read (&amp;kgdb_active) != -1 || dbg_kdb_mode) return;  local_irq_save (flags);  gdbstub_msg_write (s, count);  local_irq_restore (flags); }static struct console kgdbcons = { .name = &quot;kgdb&quot;, .write = kgdb_console_write, .flags = CON_PRINTBUFFER | CON_ENABLED, .index = -1,};  #ifdef CONFIG_MAGIC_SYSRQstatic void sysrq_handle_dbg (int key){ if  (!dbg_io_ops) { printk (KERN_CRIT &quot;ERROR: No KGDB I/O module available\n&quot;);  return;  } if  (!kgdb_connected) { #ifdef CONFIG_KGDB_KDB if  (!dbg_kdb_mode) printk (KERN_CRIT &quot;KGDB or $3 #33 for KDB\n&quot;);  #else printk (KERN_CRIT &quot;Entering KGDB\n&quot;);  #endif } kgdb_breakpoint (); }static struct sysrq_key_op sysrq_dbg_op = { .handler = sysrq_handle_dbg, .help_msg = &quot;debug (g)&quot;, .action_msg = &quot;DEBUG&quot;,};  #endifstatic int kgdb_panic_event (struct notifier_block *self, unsigned long val, void *data){ if  (dbg_kdb_mode) kdb_printf (&quot;PANIC: %s\n&quot;,  (char *)data);  kgdb_breakpoint ();  return NOTIFY_DONE; }static struct notifier_block kgdb_panic_event_nb = { .notifier_call = kgdb_panic_event, .priority = INT_MAX,}; void __weak kgdb_arch_late (void){}void __init dbg_late_init (void){ dbg_is_early = false;  if  (kgdb_io_module_registered) kgdb_arch_late ();  kdb_init (KDB_INIT_FULL); }static intdbg_notify_reboot (struct notifier_block *this, unsigned long code, void *x){ switch  (kgdbreboot) { case 1: kgdb_breakpoint ();  case -1: goto done;  } if  (!dbg_kdb_mode) gdbstub_exit (code); done: return NOTIFY_DONE; }static struct notifier_block dbg_reboot_notifier = { .notifier_call = dbg_notify_reboot, .next = NULL, .priority = INT_MAX,}; static void kgdb_register_callbacks (void){ if  (!kgdb_io_module_registered) { kgdb_io_module_registered = 1;  kgdb_arch_init ();  if  (!dbg_is_early) kgdb_arch_late ();  register_module_notifier (&amp;dbg_module_load_nb);  register_reboot_notifier (&amp;dbg_reboot_notifier);  atomic_notifier_chain_register (&amp;panic_notifier_list, &amp;kgdb_panic_event_nb);  #ifdef CONFIG_MAGIC_SYSRQ register_sysrq_key ('g', &amp;sysrq_dbg_op);  #endif if  (kgdb_use_con &amp;&amp; !kgdb_con_registered) { register_console (&amp;kgdbcons);  kgdb_con_registered = 1;  } }}static void kgdb_unregister_callbacks (void){ if  (kgdb_io_module_registered) { kgdb_io_module_registered = 0;  unregister_reboot_notifier (&amp;dbg_reboot_notifier);  unregister_module_notifier (&amp;dbg_module_load_nb);  atomic_notifier_chain_unregister (&amp;panic_notifier_list, &amp;kgdb_panic_event_nb);  kgdb_arch_exit ();  #ifdef CONFIG_MAGIC_SYSRQ unregister_sysrq_key ('g', &amp;sysrq_dbg_op);  #endif if  (kgdb_con_registered) { unregister_console (&amp;kgdbcons);  kgdb_con_registered = 0;  } }}static void kgdb_tasklet_bpt (unsigned long ing){ kgdb_breakpoint ();  atomic_set (&amp;kgdb_break_tasklet_var, 0); }static DECLARE_TASKLET (kgdb_tasklet_breakpoint, kgdb_tasklet_bpt, 0); void kgdb_schedule_breakpoint (void){ if  (atomic_read (&amp;kgdb_break_tasklet_var) || atomic_read (&amp;kgdb_active) != -1 || atomic_read (&amp;kgdb_setting_breakpoint)) return;  atomic_inc (&amp;kgdb_break_tasklet_var);  tasklet_schedule (&amp;kgdb_tasklet_breakpoint); }EXPORT_SYMBOL_GPL (kgdb_schedule_breakpoint); static void kgdb_initial_breakpoint (void){ kgdb_break_asap = 0;  printk (KERN_CRIT &quot;kgdb: Waiting for connection from remote gdb...\n&quot;);  kgdb_breakpoint (); }int kgdb_register_io_module (struct kgdb_io *new_dbg_io_ops){ int err;  spin_lock (&amp;kgdb_registration_lock);  if  (dbg_io_ops) { spin_unlock (&amp;kgdb_registration_lock);  printk (KERN_ERR &quot;kgdb: Another I/O driver is already &quot; &quot;registered with KGDB.\n&quot;);  return -EBUSY;  } if  (new_dbg_io_ops-&gt;init) { err = new_dbg_io_ops-&gt;init ();  if  (err) { spin_unlock (&amp;kgdb_registration_lock);  return err;  } } dbg_io_ops = new_dbg_io_ops;  spin_unlock (&amp;kgdb_registration_lock);  printk (KERN_INFO &quot;kgdb: Registered I/O driver %s.\n&quot;, new_dbg_io_ops-&gt;name);  kgdb_register_callbacks ();  if  (kgdb_break_asap) kgdb_initial_breakpoint ();  return 0; }EXPORT_SYMBOL_GPL (kgdb_register_io_module); void kgdb_unregister_io_module (struct kgdb_io *old_dbg_io_ops){ BUG_ON (kgdb_connected);  kgdb_unregister_callbacks ();  spin_lock (&amp;kgdb_registration_lock);  WARN_ON_ONCE (dbg_io_ops != old_dbg_io_ops);  dbg_io_ops = NULL;  spin_unlock (&amp;kgdb_registration_lock);  printk (KERN_INFO &quot;kgdb: Unregistered I/O driver %s, debugger disabled.\n&quot;, old_dbg_io_ops-&gt;name); }EXPORT_SYMBOL_GPL (kgdb_unregister_io_module); int dbg_io_get_char (void){ int ret = dbg_io_ops-&gt;read_char ();  if  (ret == NO_POLL_CHAR) return -1;  if  (!dbg_kdb_mode) return ret;  if  (ret == 127) return 8;  return ret; }void kgdb_breakpoint (void){ atomic_inc (&amp;kgdb_setting_breakpoint);  wmb ();  arch_kgdb_breakpoint ();  wmb ();  atomic_dec (&amp;kgdb_setting_breakpoint); }EXPORT_SYMBOL_GPL (kgdb_breakpoint); static int __init opt_kgdb_wait (char *str){ kgdb_break_asap = 1;  kdb_init (KDB_INIT_EARLY);  if  (kgdb_io_module_registered) kgdb_initial_breakpoint ();  return 0; }early_param (&quot;kgdbwait&quot;, opt_kgdb_wait); </flowPara></flowRoot>  <path
     sodipodi:nodetypes="cccccccc"
     inkscape:connector-curvature="0"
     id="path3217"
     d="m 33.863112,-46.296521 c 1.984772,5.676801 12.477694,12.997178 18.089337,16.950965 6.853496,4.827325 15.297003,9.616148 22.682331,12.864847 4.345116,1.915529 15.19831,4.086141 15.19831,4.086141 10.43925,1.203222 20.14106,0.863913 26.44079,0.863913 34.77804,-2.200548 64.25359,-19.15582 89.37782,-31.866125 13.01068,-6.398734 24.02348,-13.147388 23.66923,-17.14928 C 110.86291,8.152947 78.253289,-15.723834 33.863112,-46.296521 z"
     style="fill:#ffffff;stroke:#ffffff;stroke-width:3.42462206;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
  <path
     inkscape:connector-curvature="0"
     id="path3219"
     d="m 130.34533,-113.26613 c 2.367,4.767 8.394,5.397 12.504,7.794 3.894,2.16 6.057,2.58 7.551,1.71 3.45,-1.71 0.873,-7.974 -2.574,-10.134 -3.24,-2.157 -18.801,-2.607 -17.481,0.63 z"
     style="fill:#ffffff;stroke:#ffffff;stroke-opacity:1;stroke-width:4;stroke-miterlimit:4;stroke-dasharray:none" />
  <path
     inkscape:connector-curvature="0"
     id="path3221"
     d="m 82.852326,-106.12913 c -0.66,1.947 4.734,5.607 7.314,3.024 3.027,-2.367 6.477,-4.764 7.797,-5.604 5.397004,-3.477 3.237004,-5.844 -5.397,-4.557 -8.877,1.737 -8.877,5.187 -9.714,7.137 z"
     style="fill:#ffffff;stroke:#ffffff;stroke-opacity:1;stroke-width:4;stroke-miterlimit:4;stroke-dasharray:none" />
</svg>
